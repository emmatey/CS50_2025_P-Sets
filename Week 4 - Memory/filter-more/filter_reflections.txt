Another p-set, another bizarre and over engineered solution :P

My initial attempt at the blur filter was done via "brute force", and although it worked correctly, the code itself was disgusting. repetitive and difficult to maintain. 

Before this week my approach to problems has been to see what I can come up with myself, without any exposure to established solutions. My justification for this is 1. it's more fun, and 2. It forces me to be creative with my limited tool set.

The issue is, it also forms bad habits, and as things become more complex, surely at some point my brute force solutions will no longer work.

My new strategy is to search for the so called canonical solution first, read about and understand the ideas behind that, and the go back and implement it in my own system.

Notes from final attempt

The key implementation detail that I changed was to loop from int I/j = -1 in the child function. This child function is used to check the neighborhood of one pixel. Therefore if weâ€™re on pixel 0,0 and we start the child iteration at -1. we can add 0 to -1 and then later check if said direction is within bounds 0 > width/height. Since this will add to a number less than 0 it wont count said pixel. 

The sobel operator was easy to implement once I figured this out. I just had to combine this edge checking mechanism with indexing a custom defined 2d array that represented each operator. 

A big thank you to user "Salem" on "cprogramming.com" for giving me the -1 idx idea love u :3

After feeding my finished solution into an LLM, it pointed out that dynamically allocating an array with the syntax 
"RGBTRIPLE tmp_image[height][width];" makes the array on the stack instead of the heap. This didn't cause any issues
but risks a stack overflow if the image ingested is too large.

I improved the program by allocating on the heap instead. This could potentially make the program run slower because of the fragmented nature of my solution, but it seems to work instantly regardless and I feel the risk mitigation and practice was worth any risk of slowdown.

first an array of pointers which each point to the first index of an individual array of pixels was created. this initial malloc call returns a double pointer because malloc returns a pointer, and the thing it was pointing to was an array of pointers.

I then looped through this array and at each index allocated a separate array wide enough to hold the pixel structs. 
